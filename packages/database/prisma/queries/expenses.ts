import { db } from "../client";
import type { ExpenseUpdateInput } from "../generated/models/Expense";

export async function getExpenseById(id: string) {
	return db.expense.findUnique({
		where: { id },
		include: {
			expenseAccount: true,
			category: true,
			teamMember: true,
			paymentMethod: true,
			subscription: true,
		},
	});
}

export async function getExpensesByBusinessId(
	businessId: string,
	options?: {
		categoryId?: string;
		expenseType?: string;
		teamMemberId?: string;
		startDate?: Date;
		endDate?: Date;
		limit?: number;
		offset?: number;
	},
) {
	const where: any = {
		businessId,
	};

	if (options?.categoryId) {
		where.categoryId = options.categoryId;
	}

	if (options?.expenseType) {
		where.expenseType = options.expenseType;
	}

	if (options?.teamMemberId) {
		where.teamMemberId = options.teamMemberId;
	}

	if (options?.startDate || options?.endDate) {
		where.date = {};
		if (options.startDate) {
			where.date.gte = options.startDate;
		}
		if (options.endDate) {
			where.date.lte = options.endDate;
		}
	}

	return db.expense.findMany({
		where,
		include: {
			expenseAccount: true,
			category: true,
			teamMember: true,
			paymentMethod: true,
		},
		orderBy: {
			date: "desc",
		},
		take: options?.limit,
		skip: options?.offset,
	});
}

export async function getAllExpensesByOrganizationId(
	organizationId: string,
	options?: {
		categoryIds?: string[];
		accountIds?: string[];
		expenseType?: string;
		teamMemberId?: string;
		startDate?: Date;
		endDate?: Date;
		status?: string;
		search?: string;
		limit?: number;
		offset?: number;
	},
) {
	const where: any = {
		expenseAccount: {
			organizationId,
		},
	};

	if (options?.categoryIds && options.categoryIds.length > 0) {
		where.categoryId = { in: options.categoryIds };
	}

	if (options?.accountIds && options.accountIds.length > 0) {
		where.businessId = { in: options.accountIds };
	}

	if (options?.expenseType) {
		where.expenseType = options.expenseType;
	}

	if (options?.teamMemberId) {
		where.teamMemberId = options.teamMemberId;
	}

	if (options?.status) {
		where.status = options.status;
	}

	if (options?.startDate || options?.endDate) {
		where.date = {};
		if (options.startDate) {
			where.date.gte = options.startDate;
		}
		if (options.endDate) {
			where.date.lte = options.endDate;
		}
	}

	if (options?.search) {
		where.OR = [
			{ title: { contains: options.search, mode: "insensitive" } },
			{ description: { contains: options.search, mode: "insensitive" } },
		];
	}

	const [expenses, total] = await Promise.all([
		db.expense.findMany({
			where,
			include: {
				expenseAccount: {
					select: {
						id: true,
						name: true,
						currency: true,
					},
				},
				category: true,
				teamMember: {
					select: {
						id: true,
						name: true,
						email: true,
					},
				},
				paymentMethod: true,
			},
			orderBy: {
				date: "desc",
			},
			take: options?.limit,
			skip: options?.offset,
		}),
		db.expense.count({ where }),
	]);

	return {
		expenses,
		total,
	};
}

export async function createExpense(data: {
	businessId: string;
	categoryId: string;
	teamMemberId?: string;
	paymentMethodId?: string;
	title: string;
	description?: string;
	amount: number;
	currency?: string;
	conversionRate?: number;
	rateType?: string;
	baseCurrencyAmount?: number;
	date: Date;
	salaryMonth?: string;
	receiptUrl?: string;
	status?: string;
	metadata?: any;
	subscriptionId?: string;
	isAutoGenerated?: boolean;
	expenseType?: string; // "subscription", "team_salary", "one_time"
	createdBy: string;
}) {
	return db.expense.create({
		data,
	});
}

export async function updateExpense(data: ExpenseUpdateInput & { id: string }) {
	const { id, ...updateData } = data;
	return db.expense.update({
		where: { id },
		data: updateData as ExpenseUpdateInput,
	});
}

export async function deleteExpense(id: string) {
	return db.expense.delete({
		where: { id },
	});
}

export async function getExpensesTotalByBusinessId(
	businessId: string,
	startDate?: Date,
	endDate?: Date,
) {
	const where: any = {
		businessId,
		status: "active",
	};

	if (startDate || endDate) {
		where.date = {};
		if (startDate) {
			where.date.gte = startDate;
		}
		if (endDate) {
			where.date.lte = endDate;
		}
	}

	const result = await db.expense.aggregate({
		where,
		_sum: {
			amount: true,
		},
	});

	return result._sum.amount || 0;
}
